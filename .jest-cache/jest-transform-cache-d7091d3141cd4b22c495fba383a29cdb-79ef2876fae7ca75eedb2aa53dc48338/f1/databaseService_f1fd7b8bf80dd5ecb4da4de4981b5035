5ed983c6fbaf16e08eb856f40f286f93
// src/services/databaseService.js
import { getFirestore, Timestamp, FieldValue } from 'firebase-admin/firestore';
import { getAdminApp } from '../api/routes/auth/admin.js'; // Use async getAdminApp
import admin from 'firebase-admin'; // Import admin to access default app

let dbInstance = null;
async function getDb() {
  if (dbInstance) {
    return dbInstance;
  }
  if (process.env.NODE_ENV === 'test') {
    console.log('[DBService Test Env] Attempting to get Firestore instance from default app for testing.');
    try {
      // Assume the test environment (e.g., jest.emulator.setup.js or test file's beforeAll)
      // has initialized the default Firebase app.
      dbInstance = admin.firestore(); // Directly use admin.firestore() which relies on the default app
      console.log(`[DBService Test Env] Successfully obtained Firestore from default app via admin.firestore() for testing.`);
    } catch (e) {
      console.error(`[DBService Test Env] CRITICAL ERROR: Could not get Firestore using admin.firestore(). Is default app initialized? Error: ${e.message}.`);
      throw e; // Re-throw the error, as this is critical for tests.
    }
  } else {
    console.log('[DBService Prod Env] Using Firestore from adminApp.');
    const adminApp = await getAdminApp();
    dbInstance = getFirestore(adminApp);
  }
  return dbInstance;
}

/**
 * Retrieves deals that are in 'IN_FINAL_APPROVAL' state and past their finalApprovalDeadlineBackend.
 * @returns {Promise<Array<Object>>} A list of deal objects.
 */
export async function getDealsPastFinalApproval() {
  const now = Timestamp.now();
  try {
    const db = await getDb();
    const snapshot = await db.collection('deals').where('status', '==', 'IN_FINAL_APPROVAL').where('finalApprovalDeadlineBackend', '<=', now).get();
    if (snapshot.empty) {
      return [];
    }
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  } catch (error) {
    console.error('[DBService] Error fetching deals past final approval:', error);
    return [];
  }
}

/**
 * Retrieves deals that are in 'IN_DISPUTE' state and past their disputeResolutionDeadlineBackend.
 * @returns {Promise<Array<Object>>} A list of deal objects.
 */
export async function getDealsPastDisputeDeadline() {
  const now = Timestamp.now();
  try {
    const db = await getDb();
    const snapshot = await db.collection('deals').where('status', '==', 'IN_DISPUTE').where('disputeResolutionDeadlineBackend', '<=', now).get();
    if (snapshot.empty) {
      return [];
    }
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  } catch (error) {
    console.error('[DBService] Error fetching deals past dispute deadline:', error);
    return [];
  }
}

/**
 * Updates the status of a deal in Firestore and adds a timeline event.
 * @param {string} dealId The ID of the deal to update.
 * @param {object} updateData An object containing the new status and other fields to update.
 *                            Expected fields: status, timelineEventMessage.
 *                            Optional: autoReleaseTxHash, autoCancelTxHash, processingError, lastAutomaticProcessAttempt.
 */
export async function updateDealStatusInDB(dealId, updateData) {
  if (!dealId || !updateData || !updateData.status || !updateData.timelineEventMessage) {
    console.error("[DBService] Invalid parameters for updateDealStatusInDB:", {
      dealId,
      updateData
    });
    return;
  }
  try {
    const db = await getDb();
    const dealRef = db.collection('deals').doc(dealId);
    const timelineEvent = {
      event: updateData.timelineEventMessage,
      timestamp: Timestamp.now(),
      systemTriggered: true // Indicate this was an automated backend action
    };
    if (updateData.autoReleaseTxHash) {
      timelineEvent.transactionHash = updateData.autoReleaseTxHash;
    }
    if (updateData.autoCancelTxHash) {
      timelineEvent.transactionHash = updateData.autoCancelTxHash;
    }
    const firestoreUpdateData = {
      status: updateData.status,
      updatedAt: Timestamp.now(),
      timeline: FieldValue.arrayUnion(timelineEvent)
    };
    if (updateData.autoReleaseTxHash) firestoreUpdateData.autoReleaseTxHash = updateData.autoReleaseTxHash;
    if (updateData.autoCancelTxHash) firestoreUpdateData.autoCancelTxHash = updateData.autoCancelTxHash;
    if (updateData.processingError) firestoreUpdateData.processingError = updateData.processingError;
    if (updateData.lastAutomaticProcessAttempt) firestoreUpdateData.lastAutomaticProcessAttempt = updateData.lastAutomaticProcessAttempt;
    await dealRef.update(firestoreUpdateData);
    console.log(`[DBService] Deal ${dealId} status updated to ${updateData.status}. Event: "${updateData.timelineEventMessage}"`);
  } catch (error) {
    console.error(`[DBService] Error updating status for deal ${dealId} to ${updateData.status}:`, error);
    // Consider more robust error handling or logging to a dedicated error service
  }
}

/**
 * Retrieves a specific deal by its ID.
 * @param {string} dealId The ID of the deal to retrieve.
 * @returns {Promise<Object|null>} The deal object or null if not found.
 */
export async function getDealById(dealId) {
  if (!dealId) {
    console.error("[DBService] getDealById called with no dealId.");
    return null;
  }
  try {
    const db = await getDb();
    const docRef = db.collection('deals').doc(dealId);
    const docSnap = await docRef.get();
    if (docSnap.exists) {
      return {
        id: docSnap.id,
        ...docSnap.data()
      };
    } else {
      console.log(`[DBService] No deal found with ID: ${dealId}`);
      return null;
    }
  } catch (error) {
    console.error(`[DBService] Error fetching deal by ID ${dealId}:`, error);
    return null;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJnZXRGaXJlc3RvcmUiLCJUaW1lc3RhbXAiLCJGaWVsZFZhbHVlIiwiZ2V0QWRtaW5BcHAiLCJhZG1pbiIsImRiSW5zdGFuY2UiLCJnZXREYiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbnNvbGUiLCJsb2ciLCJmaXJlc3RvcmUiLCJlIiwiZXJyb3IiLCJtZXNzYWdlIiwiYWRtaW5BcHAiLCJnZXREZWFsc1Bhc3RGaW5hbEFwcHJvdmFsIiwibm93IiwiZGIiLCJzbmFwc2hvdCIsImNvbGxlY3Rpb24iLCJ3aGVyZSIsImdldCIsImVtcHR5IiwiZG9jcyIsIm1hcCIsImRvYyIsImlkIiwiZGF0YSIsImdldERlYWxzUGFzdERpc3B1dGVEZWFkbGluZSIsInVwZGF0ZURlYWxTdGF0dXNJbkRCIiwiZGVhbElkIiwidXBkYXRlRGF0YSIsInN0YXR1cyIsInRpbWVsaW5lRXZlbnRNZXNzYWdlIiwiZGVhbFJlZiIsInRpbWVsaW5lRXZlbnQiLCJldmVudCIsInRpbWVzdGFtcCIsInN5c3RlbVRyaWdnZXJlZCIsImF1dG9SZWxlYXNlVHhIYXNoIiwidHJhbnNhY3Rpb25IYXNoIiwiYXV0b0NhbmNlbFR4SGFzaCIsImZpcmVzdG9yZVVwZGF0ZURhdGEiLCJ1cGRhdGVkQXQiLCJ0aW1lbGluZSIsImFycmF5VW5pb24iLCJwcm9jZXNzaW5nRXJyb3IiLCJsYXN0QXV0b21hdGljUHJvY2Vzc0F0dGVtcHQiLCJ1cGRhdGUiLCJnZXREZWFsQnlJZCIsImRvY1JlZiIsImRvY1NuYXAiLCJleGlzdHMiXSwic291cmNlcyI6WyJkYXRhYmFzZVNlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3NlcnZpY2VzL2RhdGFiYXNlU2VydmljZS5qc1xuaW1wb3J0IHsgZ2V0RmlyZXN0b3JlLCBUaW1lc3RhbXAsIEZpZWxkVmFsdWUgfSBmcm9tICdmaXJlYmFzZS1hZG1pbi9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZ2V0QWRtaW5BcHAgfSBmcm9tICcuLi9hcGkvcm91dGVzL2F1dGgvYWRtaW4uanMnOyAvLyBVc2UgYXN5bmMgZ2V0QWRtaW5BcHBcbmltcG9ydCBhZG1pbiBmcm9tICdmaXJlYmFzZS1hZG1pbic7IC8vIEltcG9ydCBhZG1pbiB0byBhY2Nlc3MgZGVmYXVsdCBhcHBcblxubGV0IGRiSW5zdGFuY2UgPSBudWxsO1xuXG5hc3luYyBmdW5jdGlvbiBnZXREYigpIHtcbiAgaWYgKGRiSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZGJJbnN0YW5jZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgY29uc29sZS5sb2coJ1tEQlNlcnZpY2UgVGVzdCBFbnZdIEF0dGVtcHRpbmcgdG8gZ2V0IEZpcmVzdG9yZSBpbnN0YW5jZSBmcm9tIGRlZmF1bHQgYXBwIGZvciB0ZXN0aW5nLicpO1xuICAgIHRyeSB7XG4gICAgICAvLyBBc3N1bWUgdGhlIHRlc3QgZW52aXJvbm1lbnQgKGUuZy4sIGplc3QuZW11bGF0b3Iuc2V0dXAuanMgb3IgdGVzdCBmaWxlJ3MgYmVmb3JlQWxsKVxuICAgICAgLy8gaGFzIGluaXRpYWxpemVkIHRoZSBkZWZhdWx0IEZpcmViYXNlIGFwcC5cbiAgICAgIGRiSW5zdGFuY2UgPSBhZG1pbi5maXJlc3RvcmUoKTsgLy8gRGlyZWN0bHkgdXNlIGFkbWluLmZpcmVzdG9yZSgpIHdoaWNoIHJlbGllcyBvbiB0aGUgZGVmYXVsdCBhcHBcbiAgICAgIGNvbnNvbGUubG9nKGBbREJTZXJ2aWNlIFRlc3QgRW52XSBTdWNjZXNzZnVsbHkgb2J0YWluZWQgRmlyZXN0b3JlIGZyb20gZGVmYXVsdCBhcHAgdmlhIGFkbWluLmZpcmVzdG9yZSgpIGZvciB0ZXN0aW5nLmApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtEQlNlcnZpY2UgVGVzdCBFbnZdIENSSVRJQ0FMIEVSUk9SOiBDb3VsZCBub3QgZ2V0IEZpcmVzdG9yZSB1c2luZyBhZG1pbi5maXJlc3RvcmUoKS4gSXMgZGVmYXVsdCBhcHAgaW5pdGlhbGl6ZWQ/IEVycm9yOiAke2UubWVzc2FnZX0uYCk7XG4gICAgICB0aHJvdyBlOyAvLyBSZS10aHJvdyB0aGUgZXJyb3IsIGFzIHRoaXMgaXMgY3JpdGljYWwgZm9yIHRlc3RzLlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygnW0RCU2VydmljZSBQcm9kIEVudl0gVXNpbmcgRmlyZXN0b3JlIGZyb20gYWRtaW5BcHAuJyk7XG4gICAgY29uc3QgYWRtaW5BcHAgPSBhd2FpdCBnZXRBZG1pbkFwcCgpO1xuICAgIGRiSW5zdGFuY2UgPSBnZXRGaXJlc3RvcmUoYWRtaW5BcHApO1xuICB9XG4gIHJldHVybiBkYkluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBkZWFscyB0aGF0IGFyZSBpbiAnSU5fRklOQUxfQVBQUk9WQUwnIHN0YXRlIGFuZCBwYXN0IHRoZWlyIGZpbmFsQXBwcm92YWxEZWFkbGluZUJhY2tlbmQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn0gQSBsaXN0IG9mIGRlYWwgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldERlYWxzUGFzdEZpbmFsQXBwcm92YWwoKSB7XG4gIGNvbnN0IG5vdyA9IFRpbWVzdGFtcC5ub3coKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiKCk7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdkZWFscycpXG4gICAgICAud2hlcmUoJ3N0YXR1cycsICc9PScsICdJTl9GSU5BTF9BUFBST1ZBTCcpXG4gICAgICAud2hlcmUoJ2ZpbmFsQXBwcm92YWxEZWFkbGluZUJhY2tlbmQnLCAnPD0nLCBub3cpXG4gICAgICAuZ2V0KCk7XG5cbiAgICBpZiAoc25hcHNob3QuZW1wdHkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoeyBpZDogZG9jLmlkLCAuLi5kb2MuZGF0YSgpIH0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbREJTZXJ2aWNlXSBFcnJvciBmZXRjaGluZyBkZWFscyBwYXN0IGZpbmFsIGFwcHJvdmFsOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgZGVhbHMgdGhhdCBhcmUgaW4gJ0lOX0RJU1BVVEUnIHN0YXRlIGFuZCBwYXN0IHRoZWlyIGRpc3B1dGVSZXNvbHV0aW9uRGVhZGxpbmVCYWNrZW5kLlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59IEEgbGlzdCBvZiBkZWFsIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsc1Bhc3REaXNwdXRlRGVhZGxpbmUoKSB7XG4gIGNvbnN0IG5vdyA9IFRpbWVzdGFtcC5ub3coKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiKCk7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBkYi5jb2xsZWN0aW9uKCdkZWFscycpXG4gICAgICAud2hlcmUoJ3N0YXR1cycsICc9PScsICdJTl9ESVNQVVRFJylcbiAgICAgIC53aGVyZSgnZGlzcHV0ZVJlc29sdXRpb25EZWFkbGluZUJhY2tlbmQnLCAnPD0nLCBub3cpXG4gICAgICAuZ2V0KCk7XG5cbiAgICBpZiAoc25hcHNob3QuZW1wdHkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoeyBpZDogZG9jLmlkLCAuLi5kb2MuZGF0YSgpIH0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbREJTZXJ2aWNlXSBFcnJvciBmZXRjaGluZyBkZWFscyBwYXN0IGRpc3B1dGUgZGVhZGxpbmU6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIGRlYWwgaW4gRmlyZXN0b3JlIGFuZCBhZGRzIGEgdGltZWxpbmUgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVhbElkIFRoZSBJRCBvZiB0aGUgZGVhbCB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdXBkYXRlRGF0YSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IHN0YXR1cyBhbmQgb3RoZXIgZmllbGRzIHRvIHVwZGF0ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4cGVjdGVkIGZpZWxkczogc3RhdHVzLCB0aW1lbGluZUV2ZW50TWVzc2FnZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbmFsOiBhdXRvUmVsZWFzZVR4SGFzaCwgYXV0b0NhbmNlbFR4SGFzaCwgcHJvY2Vzc2luZ0Vycm9yLCBsYXN0QXV0b21hdGljUHJvY2Vzc0F0dGVtcHQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVEZWFsU3RhdHVzSW5EQihkZWFsSWQsIHVwZGF0ZURhdGEpIHtcbiAgaWYgKCFkZWFsSWQgfHwgIXVwZGF0ZURhdGEgfHwgIXVwZGF0ZURhdGEuc3RhdHVzIHx8ICF1cGRhdGVEYXRhLnRpbWVsaW5lRXZlbnRNZXNzYWdlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltEQlNlcnZpY2VdIEludmFsaWQgcGFyYW1ldGVycyBmb3IgdXBkYXRlRGVhbFN0YXR1c0luREI6XCIsIHsgZGVhbElkLCB1cGRhdGVEYXRhIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGIoKTtcbiAgICBjb25zdCBkZWFsUmVmID0gZGIuY29sbGVjdGlvbignZGVhbHMnKS5kb2MoZGVhbElkKTtcbiAgICBcbiAgICBjb25zdCB0aW1lbGluZUV2ZW50ID0ge1xuICAgICAgZXZlbnQ6IHVwZGF0ZURhdGEudGltZWxpbmVFdmVudE1lc3NhZ2UsXG4gICAgICB0aW1lc3RhbXA6IFRpbWVzdGFtcC5ub3coKSxcbiAgICAgIHN5c3RlbVRyaWdnZXJlZDogdHJ1ZSwgLy8gSW5kaWNhdGUgdGhpcyB3YXMgYW4gYXV0b21hdGVkIGJhY2tlbmQgYWN0aW9uXG4gICAgfTtcblxuICAgIGlmICh1cGRhdGVEYXRhLmF1dG9SZWxlYXNlVHhIYXNoKSB7XG4gICAgICB0aW1lbGluZUV2ZW50LnRyYW5zYWN0aW9uSGFzaCA9IHVwZGF0ZURhdGEuYXV0b1JlbGVhc2VUeEhhc2g7XG4gICAgfVxuICAgIGlmICh1cGRhdGVEYXRhLmF1dG9DYW5jZWxUeEhhc2gpIHtcbiAgICAgIHRpbWVsaW5lRXZlbnQudHJhbnNhY3Rpb25IYXNoID0gdXBkYXRlRGF0YS5hdXRvQ2FuY2VsVHhIYXNoO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcmVzdG9yZVVwZGF0ZURhdGEgPSB7XG4gICAgICBzdGF0dXM6IHVwZGF0ZURhdGEuc3RhdHVzLFxuICAgICAgdXBkYXRlZEF0OiBUaW1lc3RhbXAubm93KCksXG4gICAgICB0aW1lbGluZTogRmllbGRWYWx1ZS5hcnJheVVuaW9uKHRpbWVsaW5lRXZlbnQpLFxuICAgIH07XG5cbiAgICBpZiAodXBkYXRlRGF0YS5hdXRvUmVsZWFzZVR4SGFzaCkgZmlyZXN0b3JlVXBkYXRlRGF0YS5hdXRvUmVsZWFzZVR4SGFzaCA9IHVwZGF0ZURhdGEuYXV0b1JlbGVhc2VUeEhhc2g7XG4gICAgaWYgKHVwZGF0ZURhdGEuYXV0b0NhbmNlbFR4SGFzaCkgZmlyZXN0b3JlVXBkYXRlRGF0YS5hdXRvQ2FuY2VsVHhIYXNoID0gdXBkYXRlRGF0YS5hdXRvQ2FuY2VsVHhIYXNoO1xuICAgIGlmICh1cGRhdGVEYXRhLnByb2Nlc3NpbmdFcnJvcikgZmlyZXN0b3JlVXBkYXRlRGF0YS5wcm9jZXNzaW5nRXJyb3IgPSB1cGRhdGVEYXRhLnByb2Nlc3NpbmdFcnJvcjtcbiAgICBpZiAodXBkYXRlRGF0YS5sYXN0QXV0b21hdGljUHJvY2Vzc0F0dGVtcHQpIGZpcmVzdG9yZVVwZGF0ZURhdGEubGFzdEF1dG9tYXRpY1Byb2Nlc3NBdHRlbXB0ID0gdXBkYXRlRGF0YS5sYXN0QXV0b21hdGljUHJvY2Vzc0F0dGVtcHQ7XG5cblxuICAgIGF3YWl0IGRlYWxSZWYudXBkYXRlKGZpcmVzdG9yZVVwZGF0ZURhdGEpO1xuICAgIGNvbnNvbGUubG9nKGBbREJTZXJ2aWNlXSBEZWFsICR7ZGVhbElkfSBzdGF0dXMgdXBkYXRlZCB0byAke3VwZGF0ZURhdGEuc3RhdHVzfS4gRXZlbnQ6IFwiJHt1cGRhdGVEYXRhLnRpbWVsaW5lRXZlbnRNZXNzYWdlfVwiYCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW0RCU2VydmljZV0gRXJyb3IgdXBkYXRpbmcgc3RhdHVzIGZvciBkZWFsICR7ZGVhbElkfSB0byAke3VwZGF0ZURhdGEuc3RhdHVzfTpgLCBlcnJvcik7XG4gICAgLy8gQ29uc2lkZXIgbW9yZSByb2J1c3QgZXJyb3IgaGFuZGxpbmcgb3IgbG9nZ2luZyB0byBhIGRlZGljYXRlZCBlcnJvciBzZXJ2aWNlXG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBzcGVjaWZpYyBkZWFsIGJ5IGl0cyBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWFsSWQgVGhlIElEIG9mIHRoZSBkZWFsIHRvIHJldHJpZXZlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0fG51bGw+fSBUaGUgZGVhbCBvYmplY3Qgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREZWFsQnlJZChkZWFsSWQpIHtcbiAgaWYgKCFkZWFsSWQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW0RCU2VydmljZV0gZ2V0RGVhbEJ5SWQgY2FsbGVkIHdpdGggbm8gZGVhbElkLlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGIoKTtcbiAgICBjb25zdCBkb2NSZWYgPSBkYi5jb2xsZWN0aW9uKCdkZWFscycpLmRvYyhkZWFsSWQpO1xuICAgIGNvbnN0IGRvY1NuYXAgPSBhd2FpdCBkb2NSZWYuZ2V0KCk7XG4gICAgaWYgKGRvY1NuYXAuZXhpc3RzKSB7XG4gICAgICByZXR1cm4geyBpZDogZG9jU25hcC5pZCwgLi4uZG9jU25hcC5kYXRhKCkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYFtEQlNlcnZpY2VdIE5vIGRlYWwgZm91bmQgd2l0aCBJRDogJHtkZWFsSWR9YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW0RCU2VydmljZV0gRXJyb3IgZmV0Y2hpbmcgZGVhbCBieSBJRCAke2RlYWxJZH06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsU0FBU0EsWUFBWSxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsUUFBUSwwQkFBMEI7QUFDOUUsU0FBU0MsV0FBVyxRQUFRLDZCQUE2QixDQUFDLENBQUM7QUFDM0QsT0FBT0MsS0FBSyxNQUFNLGdCQUFnQixDQUFDLENBQUM7O0FBRXBDLElBQUlDLFVBQVUsR0FBRyxJQUFJO0FBRXJCLGVBQWVDLEtBQUtBLENBQUEsRUFBRztFQUNyQixJQUFJRCxVQUFVLEVBQUU7SUFDZCxPQUFPQSxVQUFVO0VBQ25CO0VBRUEsSUFBSUUsT0FBTyxDQUFDQyxHQUFHLENBQUNDLFFBQVEsS0FBSyxNQUFNLEVBQUU7SUFDbkNDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLHlGQUF5RixDQUFDO0lBQ3RHLElBQUk7TUFDRjtNQUNBO01BQ0FOLFVBQVUsR0FBR0QsS0FBSyxDQUFDUSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDaENGLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLDBHQUEwRyxDQUFDO0lBQ3pILENBQUMsQ0FBQyxPQUFPRSxDQUFDLEVBQUU7TUFDVkgsT0FBTyxDQUFDSSxLQUFLLENBQUMsNEhBQTRIRCxDQUFDLENB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